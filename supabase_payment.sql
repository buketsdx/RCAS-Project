-- Payment & Auto-Key Generation Logic
-- Run this in Supabase SQL Editor

-- 1. Payments Table
CREATE TABLE IF NOT EXISTS "payments" (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid REFERENCES auth.users(id),
  amount numeric NOT NULL,
  currency text DEFAULT 'USD',
  status text DEFAULT 'pending', -- 'pending', 'completed', 'failed'
  provider_id text, -- e.g., 'stripe_charge_xxx'
  created_at timestamptz DEFAULT now()
);

-- 2. Enable RLS on Payments
ALTER TABLE "payments" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own payments" ON "payments"
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Admins view all payments" ON "payments"
  FOR ALL USING (
    auth.jwt() ->> 'email' = 'admin@example.com' -- Replace with real admin check
    OR auth.role() = 'service_role'
  );

-- 3. Function to Generate Random Key
CREATE OR REPLACE FUNCTION generate_license_key() RETURNS text AS $$
DECLARE
  chars text[] := '{A,B,C,D,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,U,V,W,X,Y,Z,2,3,4,5,6,7,8,9}';
  result text := 'RCAS-';
  i integer;
BEGIN
  -- Segment 1
  FOR i IN 1..4 LOOP
    result := result || chars[1+floor(random()*(array_length(chars, 1)-1))::int];
  END LOOP;
  result := result || '-';
  -- Segment 2
  FOR i IN 1..4 LOOP
    result := result || chars[1+floor(random()*(array_length(chars, 1)-1))::int];
  END LOOP;
  RETURN result;
END;
$$ LANGUAGE plpgsql;

-- 4. Transactional Payment Processing (Simulated)
-- This function simulates a successful payment and auto-generates a key
CREATE OR REPLACE FUNCTION process_mock_payment(payment_amount numeric)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  user_id uuid;
  new_payment_id bigint;
  new_key text;
  key_exists boolean;
BEGIN
  user_id := auth.uid();
  IF user_id IS NULL THEN
    RETURN json_build_object('success', false, 'message', 'User not authenticated');
  END IF;

  -- A. Record Payment
  INSERT INTO "payments" (user_id, amount, status, provider_id)
  VALUES (user_id, payment_amount, 'completed', 'mock_provider_' || floor(random()*100000)::text)
  RETURNING id INTO new_payment_id;

  -- B. Generate Unique Key
  LOOP
    new_key := generate_license_key();
    SELECT EXISTS(SELECT 1 FROM "subscription_keys" WHERE key_code = new_key) INTO key_exists;
    EXIT WHEN NOT key_exists;
  END LOOP;

  -- C. Create Key (Linked to User but NOT claimed yet, or claimed? User asked "mile user ko")
  -- Let's create it as 'active' and give it to the user. They can then click "Activate".
  -- OR: We can auto-claim it.
  -- "Auto generate hoke mile" -> Generated and received.
  -- Let's auto-claim it for seamless UX, but return it so they see it.
  
  INSERT INTO "subscription_keys" (key_code, plan_type, status, claimed_by, claimed_at)
  VALUES (new_key, 'premium', 'used', user_id, now());

  RETURN json_build_object(
    'success', true, 
    'message', 'Payment successful! Key generated.',
    'key', new_key,
    'payment_id', new_payment_id
  );
END;
$$;
